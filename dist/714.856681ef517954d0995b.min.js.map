{"version":3,"file":"714.856681ef517954d0995b.min.js","mappings":"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","sources":["webpack://pwdgen2/./node_modules/stacktrace-gps/node_modules/source-map/lib/util.js","webpack://pwdgen2/./node_modules/stacktrace-gps/node_modules/source-map/source-map.js","webpack://pwdgen2/./node_modules/stacktrace-gps/stacktrace-gps.js"],"sourcesContent":["/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\n/**\n * This is a helper function for getting values from parameter/options\n * objects.\n *\n * @param args The object we are extracting values from\n * @param name The name of the property we are getting.\n * @param defaultValue An optional value to return if the property is missing\n * from the object. If this is not specified and the property is missing, an\n * error will be thrown.\n */\nfunction getArg(aArgs, aName, aDefaultValue) {\n  if (aName in aArgs) {\n    return aArgs[aName];\n  } else if (arguments.length === 3) {\n    return aDefaultValue;\n  } else {\n    throw new Error('\"' + aName + '\" is a required argument.');\n  }\n}\nexports.getArg = getArg;\n\nvar urlRegexp = /^(?:([\\w+\\-.]+):)?\\/\\/(?:(\\w+:\\w+)@)?([\\w.]*)(?::(\\d+))?(\\S*)$/;\nvar dataUrlRegexp = /^data:.+\\,.+$/;\n\nfunction urlParse(aUrl) {\n  var match = aUrl.match(urlRegexp);\n  if (!match) {\n    return null;\n  }\n  return {\n    scheme: match[1],\n    auth: match[2],\n    host: match[3],\n    port: match[4],\n    path: match[5]\n  };\n}\nexports.urlParse = urlParse;\n\nfunction urlGenerate(aParsedUrl) {\n  var url = '';\n  if (aParsedUrl.scheme) {\n    url += aParsedUrl.scheme + ':';\n  }\n  url += '//';\n  if (aParsedUrl.auth) {\n    url += aParsedUrl.auth + '@';\n  }\n  if (aParsedUrl.host) {\n    url += aParsedUrl.host;\n  }\n  if (aParsedUrl.port) {\n    url += \":\" + aParsedUrl.port\n  }\n  if (aParsedUrl.path) {\n    url += aParsedUrl.path;\n  }\n  return url;\n}\nexports.urlGenerate = urlGenerate;\n\n/**\n * Normalizes a path, or the path portion of a URL:\n *\n * - Replaces consecutive slashes with one slash.\n * - Removes unnecessary '.' parts.\n * - Removes unnecessary '<dir>/..' parts.\n *\n * Based on code in the Node.js 'path' core module.\n *\n * @param aPath The path or url to normalize.\n */\nfunction normalize(aPath) {\n  var path = aPath;\n  var url = urlParse(aPath);\n  if (url) {\n    if (!url.path) {\n      return aPath;\n    }\n    path = url.path;\n  }\n  var isAbsolute = exports.isAbsolute(path);\n\n  var parts = path.split(/\\/+/);\n  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {\n    part = parts[i];\n    if (part === '.') {\n      parts.splice(i, 1);\n    } else if (part === '..') {\n      up++;\n    } else if (up > 0) {\n      if (part === '') {\n        // The first part is blank if the path is absolute. Trying to go\n        // above the root is a no-op. Therefore we can remove all '..' parts\n        // directly after the root.\n        parts.splice(i + 1, up);\n        up = 0;\n      } else {\n        parts.splice(i, 2);\n        up--;\n      }\n    }\n  }\n  path = parts.join('/');\n\n  if (path === '') {\n    path = isAbsolute ? '/' : '.';\n  }\n\n  if (url) {\n    url.path = path;\n    return urlGenerate(url);\n  }\n  return path;\n}\nexports.normalize = normalize;\n\n/**\n * Joins two paths/URLs.\n *\n * @param aRoot The root path or URL.\n * @param aPath The path or URL to be joined with the root.\n *\n * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a\n *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended\n *   first.\n * - Otherwise aPath is a path. If aRoot is a URL, then its path portion\n *   is updated with the result and aRoot is returned. Otherwise the result\n *   is returned.\n *   - If aPath is absolute, the result is aPath.\n *   - Otherwise the two paths are joined with a slash.\n * - Joining for example 'http://' and 'www.example.com' is also supported.\n */\nfunction join(aRoot, aPath) {\n  if (aRoot === \"\") {\n    aRoot = \".\";\n  }\n  if (aPath === \"\") {\n    aPath = \".\";\n  }\n  var aPathUrl = urlParse(aPath);\n  var aRootUrl = urlParse(aRoot);\n  if (aRootUrl) {\n    aRoot = aRootUrl.path || '/';\n  }\n\n  // `join(foo, '//www.example.org')`\n  if (aPathUrl && !aPathUrl.scheme) {\n    if (aRootUrl) {\n      aPathUrl.scheme = aRootUrl.scheme;\n    }\n    return urlGenerate(aPathUrl);\n  }\n\n  if (aPathUrl || aPath.match(dataUrlRegexp)) {\n    return aPath;\n  }\n\n  // `join('http://', 'www.example.com')`\n  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {\n    aRootUrl.host = aPath;\n    return urlGenerate(aRootUrl);\n  }\n\n  var joined = aPath.charAt(0) === '/'\n    ? aPath\n    : normalize(aRoot.replace(/\\/+$/, '') + '/' + aPath);\n\n  if (aRootUrl) {\n    aRootUrl.path = joined;\n    return urlGenerate(aRootUrl);\n  }\n  return joined;\n}\nexports.join = join;\n\nexports.isAbsolute = function (aPath) {\n  return aPath.charAt(0) === '/' || !!aPath.match(urlRegexp);\n};\n\n/**\n * Make a path relative to a URL or another path.\n *\n * @param aRoot The root path or URL.\n * @param aPath The path or URL to be made relative to aRoot.\n */\nfunction relative(aRoot, aPath) {\n  if (aRoot === \"\") {\n    aRoot = \".\";\n  }\n\n  aRoot = aRoot.replace(/\\/$/, '');\n\n  // It is possible for the path to be above the root. In this case, simply\n  // checking whether the root is a prefix of the path won't work. Instead, we\n  // need to remove components from the root one by one, until either we find\n  // a prefix that fits, or we run out of components to remove.\n  var level = 0;\n  while (aPath.indexOf(aRoot + '/') !== 0) {\n    var index = aRoot.lastIndexOf(\"/\");\n    if (index < 0) {\n      return aPath;\n    }\n\n    // If the only part of the root that is left is the scheme (i.e. http://,\n    // file:///, etc.), one or more slashes (/), or simply nothing at all, we\n    // have exhausted all components, so the path is not relative to the root.\n    aRoot = aRoot.slice(0, index);\n    if (aRoot.match(/^([^\\/]+:\\/)?\\/*$/)) {\n      return aPath;\n    }\n\n    ++level;\n  }\n\n  // Make sure we add a \"../\" for each component we removed from the root.\n  return Array(level + 1).join(\"../\") + aPath.substr(aRoot.length + 1);\n}\nexports.relative = relative;\n\nvar supportsNullProto = (function () {\n  var obj = Object.create(null);\n  return !('__proto__' in obj);\n}());\n\nfunction identity (s) {\n  return s;\n}\n\n/**\n * Because behavior goes wacky when you set `__proto__` on objects, we\n * have to prefix all the strings in our set with an arbitrary character.\n *\n * See https://github.com/mozilla/source-map/pull/31 and\n * https://github.com/mozilla/source-map/issues/30\n *\n * @param String aStr\n */\nfunction toSetString(aStr) {\n  if (isProtoString(aStr)) {\n    return '$' + aStr;\n  }\n\n  return aStr;\n}\nexports.toSetString = supportsNullProto ? identity : toSetString;\n\nfunction fromSetString(aStr) {\n  if (isProtoString(aStr)) {\n    return aStr.slice(1);\n  }\n\n  return aStr;\n}\nexports.fromSetString = supportsNullProto ? identity : fromSetString;\n\nfunction isProtoString(s) {\n  if (!s) {\n    return false;\n  }\n\n  var length = s.length;\n\n  if (length < 9 /* \"__proto__\".length */) {\n    return false;\n  }\n\n  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||\n      s.charCodeAt(length - 2) !== 95  /* '_' */ ||\n      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||\n      s.charCodeAt(length - 4) !== 116 /* 't' */ ||\n      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||\n      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||\n      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||\n      s.charCodeAt(length - 8) !== 95  /* '_' */ ||\n      s.charCodeAt(length - 9) !== 95  /* '_' */) {\n    return false;\n  }\n\n  for (var i = length - 10; i >= 0; i--) {\n    if (s.charCodeAt(i) !== 36 /* '$' */) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Comparator between two mappings where the original positions are compared.\n *\n * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n * mappings with the same original source/line/column, but different generated\n * line and column the same. Useful when searching for a mapping with a\n * stubbed out mapping.\n */\nfunction compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {\n  var cmp = mappingA.source - mappingB.source;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0 || onlyCompareOriginal) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedLine - mappingB.generatedLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return mappingA.name - mappingB.name;\n}\nexports.compareByOriginalPositions = compareByOriginalPositions;\n\n/**\n * Comparator between two mappings with deflated source and name indices where\n * the generated positions are compared.\n *\n * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n * mappings with the same generated line and column, but different\n * source/name/original line and column the same. Useful when searching for a\n * mapping with a stubbed out mapping.\n */\nfunction compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {\n  var cmp = mappingA.generatedLine - mappingB.generatedLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0 || onlyCompareGenerated) {\n    return cmp;\n  }\n\n  cmp = mappingA.source - mappingB.source;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return mappingA.name - mappingB.name;\n}\nexports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;\n\nfunction strcmp(aStr1, aStr2) {\n  if (aStr1 === aStr2) {\n    return 0;\n  }\n\n  if (aStr1 > aStr2) {\n    return 1;\n  }\n\n  return -1;\n}\n\n/**\n * Comparator between two mappings with inflated source and name strings where\n * the generated positions are compared.\n */\nfunction compareByGeneratedPositionsInflated(mappingA, mappingB) {\n  var cmp = mappingA.generatedLine - mappingB.generatedLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = strcmp(mappingA.source, mappingB.source);\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return strcmp(mappingA.name, mappingB.name);\n}\nexports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;\n","/*\n * Copyright 2009-2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE.txt or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\nexports.SourceMapGenerator = require('./lib/source-map-generator').SourceMapGenerator;\nexports.SourceMapConsumer = require('./lib/source-map-consumer').SourceMapConsumer;\nexports.SourceNode = require('./lib/source-node').SourceNode;\n","(function(root, factory) {\n    'use strict';\n    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.\n\n    /* istanbul ignore next */\n    if (typeof define === 'function' && define.amd) {\n        define('stacktrace-gps', ['source-map', 'stackframe'], factory);\n    } else if (typeof exports === 'object') {\n        module.exports = factory(require('source-map/lib/source-map-consumer'), require('stackframe'));\n    } else {\n        root.StackTraceGPS = factory(root.SourceMap || root.sourceMap, root.StackFrame);\n    }\n}(this, function(SourceMap, StackFrame) {\n    'use strict';\n\n    /**\n     * Make a X-Domain request to url and callback.\n     *\n     * @param {String} url\n     * @returns {Promise} with response text if fulfilled\n     */\n    function _xdr(url) {\n        return new Promise(function(resolve, reject) {\n            var req = new XMLHttpRequest();\n            req.open('get', url);\n            req.onerror = reject;\n            req.onreadystatechange = function onreadystatechange() {\n                if (req.readyState === 4) {\n                    if ((req.status >= 200 && req.status < 300) ||\n                        (url.substr(0, 7) === 'file://' && req.responseText)) {\n                        resolve(req.responseText);\n                    } else {\n                        reject(new Error('HTTP status: ' + req.status + ' retrieving ' + url));\n                    }\n                }\n            };\n            req.send();\n        });\n\n    }\n\n    /**\n     * Convert a Base64-encoded string into its original representation.\n     * Used for inline sourcemaps.\n     *\n     * @param {String} b64str Base-64 encoded string\n     * @returns {String} original representation of the base64-encoded string.\n     */\n    function _atob(b64str) {\n        if (typeof window !== 'undefined' && window.atob) {\n            return window.atob(b64str);\n        } else {\n            throw new Error('You must supply a polyfill for window.atob in this environment');\n        }\n    }\n\n    function _parseJson(string) {\n        if (typeof JSON !== 'undefined' && JSON.parse) {\n            return JSON.parse(string);\n        } else {\n            throw new Error('You must supply a polyfill for JSON.parse in this environment');\n        }\n    }\n\n    function _findFunctionName(source, lineNumber/*, columnNumber*/) {\n        var syntaxes = [\n            // {name} = function ({args}) TODO args capture\n            /['\"]?([$_A-Za-z][$_A-Za-z0-9]*)['\"]?\\s*[:=]\\s*function\\b/,\n            // function {name}({args}) m[1]=name m[2]=args\n            /function\\s+([^('\"`]*?)\\s*\\(([^)]*)\\)/,\n            // {name} = eval()\n            /['\"]?([$_A-Za-z][$_A-Za-z0-9]*)['\"]?\\s*[:=]\\s*(?:eval|new Function)\\b/,\n            // fn_name() {\n            /\\b(?!(?:if|for|switch|while|with|catch)\\b)(?:(?:static)\\s+)?(\\S+)\\s*\\(.*?\\)\\s*\\{/,\n            // {name} = () => {\n            /['\"]?([$_A-Za-z][$_A-Za-z0-9]*)['\"]?\\s*[:=]\\s*\\(.*?\\)\\s*=>/\n        ];\n        var lines = source.split('\\n');\n\n        // Walk backwards in the source lines until we find the line which matches one of the patterns above\n        var code = '';\n        var maxLines = Math.min(lineNumber, 20);\n        for (var i = 0; i < maxLines; ++i) {\n            // lineNo is 1-based, source[] is 0-based\n            var line = lines[lineNumber - i - 1];\n            var commentPos = line.indexOf('//');\n            if (commentPos >= 0) {\n                line = line.substr(0, commentPos);\n            }\n\n            if (line) {\n                code = line + code;\n                var len = syntaxes.length;\n                for (var index = 0; index < len; index++) {\n                    var m = syntaxes[index].exec(code);\n                    if (m && m[1]) {\n                        return m[1];\n                    }\n                }\n            }\n        }\n        return undefined;\n    }\n\n    function _ensureSupportedEnvironment() {\n        if (typeof Object.defineProperty !== 'function' || typeof Object.create !== 'function') {\n            throw new Error('Unable to consume source maps in older browsers');\n        }\n    }\n\n    function _ensureStackFrameIsLegit(stackframe) {\n        if (typeof stackframe !== 'object') {\n            throw new TypeError('Given StackFrame is not an object');\n        } else if (typeof stackframe.fileName !== 'string') {\n            throw new TypeError('Given file name is not a String');\n        } else if (typeof stackframe.lineNumber !== 'number' ||\n            stackframe.lineNumber % 1 !== 0 ||\n            stackframe.lineNumber < 1) {\n            throw new TypeError('Given line number must be a positive integer');\n        } else if (typeof stackframe.columnNumber !== 'number' ||\n            stackframe.columnNumber % 1 !== 0 ||\n            stackframe.columnNumber < 0) {\n            throw new TypeError('Given column number must be a non-negative integer');\n        }\n        return true;\n    }\n\n    function _findSourceMappingURL(source) {\n        var sourceMappingUrlRegExp = /\\/\\/[#@] ?sourceMappingURL=([^\\s'\"]+)\\s*$/mg;\n        var lastSourceMappingUrl;\n        var matchSourceMappingUrl;\n        // eslint-disable-next-line no-cond-assign\n        while (matchSourceMappingUrl = sourceMappingUrlRegExp.exec(source)) {\n            lastSourceMappingUrl = matchSourceMappingUrl[1];\n        }\n        if (lastSourceMappingUrl) {\n            return lastSourceMappingUrl;\n        } else {\n            throw new Error('sourceMappingURL not found');\n        }\n    }\n\n    function _extractLocationInfoFromSourceMapSource(stackframe, sourceMapConsumer, sourceCache) {\n        return new Promise(function(resolve, reject) {\n            var loc = sourceMapConsumer.originalPositionFor({\n                line: stackframe.lineNumber,\n                column: stackframe.columnNumber\n            });\n\n            if (loc.source) {\n                // cache mapped sources\n                var mappedSource = sourceMapConsumer.sourceContentFor(loc.source);\n                if (mappedSource) {\n                    sourceCache[loc.source] = mappedSource;\n                }\n\n                resolve(\n                    // given stackframe and source location, update stackframe\n                    new StackFrame({\n                        functionName: loc.name || stackframe.functionName,\n                        args: stackframe.args,\n                        fileName: loc.source,\n                        lineNumber: loc.line,\n                        columnNumber: loc.column\n                    }));\n            } else {\n                reject(new Error('Could not get original source for given stackframe and source map'));\n            }\n        });\n    }\n\n    /**\n     * @constructor\n     * @param {Object} opts\n     *      opts.sourceCache = {url: \"Source String\"} => preload source cache\n     *      opts.sourceMapConsumerCache = {/path/file.js.map: SourceMapConsumer}\n     *      opts.offline = True to prevent network requests.\n     *              Best effort without sources or source maps.\n     *      opts.ajax = Promise returning function to make X-Domain requests\n     */\n    return function StackTraceGPS(opts) {\n        if (!(this instanceof StackTraceGPS)) {\n            return new StackTraceGPS(opts);\n        }\n        opts = opts || {};\n\n        this.sourceCache = opts.sourceCache || {};\n        this.sourceMapConsumerCache = opts.sourceMapConsumerCache || {};\n\n        this.ajax = opts.ajax || _xdr;\n\n        this._atob = opts.atob || _atob;\n\n        this._get = function _get(location) {\n            return new Promise(function(resolve, reject) {\n                var isDataUrl = location.substr(0, 5) === 'data:';\n                if (this.sourceCache[location]) {\n                    resolve(this.sourceCache[location]);\n                } else if (opts.offline && !isDataUrl) {\n                    reject(new Error('Cannot make network requests in offline mode'));\n                } else {\n                    if (isDataUrl) {\n                        // data URLs can have parameters.\n                        // see http://tools.ietf.org/html/rfc2397\n                        var supportedEncodingRegexp =\n                            /^data:application\\/json;([\\w=:\"-]+;)*base64,/;\n                        var match = location.match(supportedEncodingRegexp);\n                        if (match) {\n                            var sourceMapStart = match[0].length;\n                            var encodedSource = location.substr(sourceMapStart);\n                            var source = this._atob(encodedSource);\n                            this.sourceCache[location] = source;\n                            resolve(source);\n                        } else {\n                            reject(new Error('The encoding of the inline sourcemap is not supported'));\n                        }\n                    } else {\n                        var xhrPromise = this.ajax(location, {method: 'get'});\n                        // Cache the Promise to prevent duplicate in-flight requests\n                        this.sourceCache[location] = xhrPromise;\n                        xhrPromise.then(resolve, reject);\n                    }\n                }\n            }.bind(this));\n        };\n\n        /**\n         * Creating SourceMapConsumers is expensive, so this wraps the creation of a\n         * SourceMapConsumer in a per-instance cache.\n         *\n         * @param {String} sourceMappingURL = URL to fetch source map from\n         * @param {String} defaultSourceRoot = Default source root for source map if undefined\n         * @returns {Promise} that resolves a SourceMapConsumer\n         */\n        this._getSourceMapConsumer = function _getSourceMapConsumer(sourceMappingURL, defaultSourceRoot) {\n            return new Promise(function(resolve) {\n                if (this.sourceMapConsumerCache[sourceMappingURL]) {\n                    resolve(this.sourceMapConsumerCache[sourceMappingURL]);\n                } else {\n                    var sourceMapConsumerPromise = new Promise(function(resolve, reject) {\n                        return this._get(sourceMappingURL).then(function(sourceMapSource) {\n                            if (typeof sourceMapSource === 'string') {\n                                sourceMapSource = _parseJson(sourceMapSource.replace(/^\\)\\]\\}'/, ''));\n                            }\n                            if (typeof sourceMapSource.sourceRoot === 'undefined') {\n                                sourceMapSource.sourceRoot = defaultSourceRoot;\n                            }\n\n                            resolve(new SourceMap.SourceMapConsumer(sourceMapSource));\n                        }).catch(reject);\n                    }.bind(this));\n                    this.sourceMapConsumerCache[sourceMappingURL] = sourceMapConsumerPromise;\n                    resolve(sourceMapConsumerPromise);\n                }\n            }.bind(this));\n        };\n\n        /**\n         * Given a StackFrame, enhance function name and use source maps for a\n         * better StackFrame.\n         *\n         * @param {StackFrame} stackframe object\n         * @returns {Promise} that resolves with with source-mapped StackFrame\n         */\n        this.pinpoint = function StackTraceGPS$$pinpoint(stackframe) {\n            return new Promise(function(resolve, reject) {\n                this.getMappedLocation(stackframe).then(function(mappedStackFrame) {\n                    function resolveMappedStackFrame() {\n                        resolve(mappedStackFrame);\n                    }\n\n                    this.findFunctionName(mappedStackFrame)\n                        .then(resolve, resolveMappedStackFrame)\n                        // eslint-disable-next-line no-unexpected-multiline\n                        ['catch'](resolveMappedStackFrame);\n                }.bind(this), reject);\n            }.bind(this));\n        };\n\n        /**\n         * Given a StackFrame, guess function name from location information.\n         *\n         * @param {StackFrame} stackframe\n         * @returns {Promise} that resolves with enhanced StackFrame.\n         */\n        this.findFunctionName = function StackTraceGPS$$findFunctionName(stackframe) {\n            return new Promise(function(resolve, reject) {\n                _ensureStackFrameIsLegit(stackframe);\n                this._get(stackframe.fileName).then(function getSourceCallback(source) {\n                    var lineNumber = stackframe.lineNumber;\n                    var columnNumber = stackframe.columnNumber;\n                    var guessedFunctionName = _findFunctionName(source, lineNumber, columnNumber);\n                    // Only replace functionName if we found something\n                    if (guessedFunctionName) {\n                        resolve(new StackFrame({\n                            functionName: guessedFunctionName,\n                            args: stackframe.args,\n                            fileName: stackframe.fileName,\n                            lineNumber: lineNumber,\n                            columnNumber: columnNumber\n                        }));\n                    } else {\n                        resolve(stackframe);\n                    }\n                }, reject)['catch'](reject);\n            }.bind(this));\n        };\n\n        /**\n         * Given a StackFrame, seek source-mapped location and return new enhanced StackFrame.\n         *\n         * @param {StackFrame} stackframe\n         * @returns {Promise} that resolves with enhanced StackFrame.\n         */\n        this.getMappedLocation = function StackTraceGPS$$getMappedLocation(stackframe) {\n            return new Promise(function(resolve, reject) {\n                _ensureSupportedEnvironment();\n                _ensureStackFrameIsLegit(stackframe);\n\n                var sourceCache = this.sourceCache;\n                var fileName = stackframe.fileName;\n                this._get(fileName).then(function(source) {\n                    var sourceMappingURL = _findSourceMappingURL(source);\n                    var isDataUrl = sourceMappingURL.substr(0, 5) === 'data:';\n                    var defaultSourceRoot = fileName.substring(0, fileName.lastIndexOf('/') + 1);\n\n                    if (sourceMappingURL[0] !== '/' && !isDataUrl && !(/^https?:\\/\\/|^\\/\\//i).test(sourceMappingURL)) {\n                        sourceMappingURL = defaultSourceRoot + sourceMappingURL;\n                    }\n\n                    return this._getSourceMapConsumer(sourceMappingURL, defaultSourceRoot)\n                        .then(function(sourceMapConsumer) {\n                            return _extractLocationInfoFromSourceMapSource(stackframe, sourceMapConsumer, sourceCache)\n                                .then(resolve)['catch'](function() {\n                                    resolve(stackframe);\n                                });\n                        });\n                }.bind(this), reject)['catch'](reject);\n            }.bind(this));\n        };\n    };\n}));\n"],"names":["exports","getArg","aArgs","aName","aDefaultValue","arguments","length","Error","urlRegexp","dataUrlRegexp","urlParse","aUrl","match","scheme","auth","host","port","path","urlGenerate","aParsedUrl","url","normalize","aPath","part","isAbsolute","parts","split","up","i","splice","join","aRoot","aPathUrl","aRootUrl","joined","charAt","replace","relative","level","indexOf","index","lastIndexOf","slice","Array","substr","supportsNullProto","Object","create","identity","s","isProtoString","charCodeAt","strcmp","aStr1","aStr2","toSetString","aStr","fromSetString","compareByOriginalPositions","mappingA","mappingB","onlyCompareOriginal","cmp","source","originalLine","originalColumn","generatedColumn","generatedLine","name","compareByGeneratedPositionsDeflated","onlyCompareGenerated","compareByGeneratedPositionsInflated","SourceMapGenerator","SourceMapConsumer","SourceNode","SourceMap","StackFrame","_xdr","Promise","resolve","reject","req","XMLHttpRequest","open","onerror","onreadystatechange","readyState","status","responseText","send","_atob","b64str","window","atob","_parseJson","string","JSON","parse","_findFunctionName","lineNumber","syntaxes","lines","code","maxLines","Math","min","line","commentPos","len","m","exec","_ensureSupportedEnvironment","defineProperty","_ensureStackFrameIsLegit","stackframe","TypeError","fileName","columnNumber","_findSourceMappingURL","lastSourceMappingUrl","matchSourceMappingUrl","sourceMappingUrlRegExp","_extractLocationInfoFromSourceMapSource","sourceMapConsumer","sourceCache","loc","originalPositionFor","column","mappedSource","sourceContentFor","functionName","args","StackTraceGPS","opts","this","sourceMapConsumerCache","ajax","_get","location","isDataUrl","offline","supportedEncodingRegexp","sourceMapStart","encodedSource","xhrPromise","method","then","bind","_getSourceMapConsumer","sourceMappingURL","defaultSourceRoot","sourceMapConsumerPromise","sourceMapSource","sourceRoot","catch","pinpoint","getMappedLocation","mappedStackFrame","resolveMappedStackFrame","findFunctionName","guessedFunctionName","substring","test"],"sourceRoot":""}