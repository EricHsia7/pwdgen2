{"version":3,"file":"401.e16b329b82c09bc5a65b.min.js","mappings":"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","sources":["webpack://pwdgen2/./node_modules/stacktrace-gps/stacktrace-gps.js","webpack://pwdgen2/./node_modules/stacktrace-js/stacktrace.js"],"sourcesContent":["(function(root, factory) {\n    'use strict';\n    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.\n\n    /* istanbul ignore next */\n    if (typeof define === 'function' && define.amd) {\n        define('stacktrace-gps', ['source-map', 'stackframe'], factory);\n    } else if (typeof exports === 'object') {\n        module.exports = factory(require('source-map/lib/source-map-consumer'), require('stackframe'));\n    } else {\n        root.StackTraceGPS = factory(root.SourceMap || root.sourceMap, root.StackFrame);\n    }\n}(this, function(SourceMap, StackFrame) {\n    'use strict';\n\n    /**\n     * Make a X-Domain request to url and callback.\n     *\n     * @param {String} url\n     * @returns {Promise} with response text if fulfilled\n     */\n    function _xdr(url) {\n        return new Promise(function(resolve, reject) {\n            var req = new XMLHttpRequest();\n            req.open('get', url);\n            req.onerror = reject;\n            req.onreadystatechange = function onreadystatechange() {\n                if (req.readyState === 4) {\n                    if ((req.status >= 200 && req.status < 300) ||\n                        (url.substr(0, 7) === 'file://' && req.responseText)) {\n                        resolve(req.responseText);\n                    } else {\n                        reject(new Error('HTTP status: ' + req.status + ' retrieving ' + url));\n                    }\n                }\n            };\n            req.send();\n        });\n\n    }\n\n    /**\n     * Convert a Base64-encoded string into its original representation.\n     * Used for inline sourcemaps.\n     *\n     * @param {String} b64str Base-64 encoded string\n     * @returns {String} original representation of the base64-encoded string.\n     */\n    function _atob(b64str) {\n        if (typeof window !== 'undefined' && window.atob) {\n            return window.atob(b64str);\n        } else {\n            throw new Error('You must supply a polyfill for window.atob in this environment');\n        }\n    }\n\n    function _parseJson(string) {\n        if (typeof JSON !== 'undefined' && JSON.parse) {\n            return JSON.parse(string);\n        } else {\n            throw new Error('You must supply a polyfill for JSON.parse in this environment');\n        }\n    }\n\n    function _findFunctionName(source, lineNumber/*, columnNumber*/) {\n        var syntaxes = [\n            // {name} = function ({args}) TODO args capture\n            /['\"]?([$_A-Za-z][$_A-Za-z0-9]*)['\"]?\\s*[:=]\\s*function\\b/,\n            // function {name}({args}) m[1]=name m[2]=args\n            /function\\s+([^('\"`]*?)\\s*\\(([^)]*)\\)/,\n            // {name} = eval()\n            /['\"]?([$_A-Za-z][$_A-Za-z0-9]*)['\"]?\\s*[:=]\\s*(?:eval|new Function)\\b/,\n            // fn_name() {\n            /\\b(?!(?:if|for|switch|while|with|catch)\\b)(?:(?:static)\\s+)?(\\S+)\\s*\\(.*?\\)\\s*\\{/,\n            // {name} = () => {\n            /['\"]?([$_A-Za-z][$_A-Za-z0-9]*)['\"]?\\s*[:=]\\s*\\(.*?\\)\\s*=>/\n        ];\n        var lines = source.split('\\n');\n\n        // Walk backwards in the source lines until we find the line which matches one of the patterns above\n        var code = '';\n        var maxLines = Math.min(lineNumber, 20);\n        for (var i = 0; i < maxLines; ++i) {\n            // lineNo is 1-based, source[] is 0-based\n            var line = lines[lineNumber - i - 1];\n            var commentPos = line.indexOf('//');\n            if (commentPos >= 0) {\n                line = line.substr(0, commentPos);\n            }\n\n            if (line) {\n                code = line + code;\n                var len = syntaxes.length;\n                for (var index = 0; index < len; index++) {\n                    var m = syntaxes[index].exec(code);\n                    if (m && m[1]) {\n                        return m[1];\n                    }\n                }\n            }\n        }\n        return undefined;\n    }\n\n    function _ensureSupportedEnvironment() {\n        if (typeof Object.defineProperty !== 'function' || typeof Object.create !== 'function') {\n            throw new Error('Unable to consume source maps in older browsers');\n        }\n    }\n\n    function _ensureStackFrameIsLegit(stackframe) {\n        if (typeof stackframe !== 'object') {\n            throw new TypeError('Given StackFrame is not an object');\n        } else if (typeof stackframe.fileName !== 'string') {\n            throw new TypeError('Given file name is not a String');\n        } else if (typeof stackframe.lineNumber !== 'number' ||\n            stackframe.lineNumber % 1 !== 0 ||\n            stackframe.lineNumber < 1) {\n            throw new TypeError('Given line number must be a positive integer');\n        } else if (typeof stackframe.columnNumber !== 'number' ||\n            stackframe.columnNumber % 1 !== 0 ||\n            stackframe.columnNumber < 0) {\n            throw new TypeError('Given column number must be a non-negative integer');\n        }\n        return true;\n    }\n\n    function _findSourceMappingURL(source) {\n        var sourceMappingUrlRegExp = /\\/\\/[#@] ?sourceMappingURL=([^\\s'\"]+)\\s*$/mg;\n        var lastSourceMappingUrl;\n        var matchSourceMappingUrl;\n        // eslint-disable-next-line no-cond-assign\n        while (matchSourceMappingUrl = sourceMappingUrlRegExp.exec(source)) {\n            lastSourceMappingUrl = matchSourceMappingUrl[1];\n        }\n        if (lastSourceMappingUrl) {\n            return lastSourceMappingUrl;\n        } else {\n            throw new Error('sourceMappingURL not found');\n        }\n    }\n\n    function _extractLocationInfoFromSourceMapSource(stackframe, sourceMapConsumer, sourceCache) {\n        return new Promise(function(resolve, reject) {\n            var loc = sourceMapConsumer.originalPositionFor({\n                line: stackframe.lineNumber,\n                column: stackframe.columnNumber\n            });\n\n            if (loc.source) {\n                // cache mapped sources\n                var mappedSource = sourceMapConsumer.sourceContentFor(loc.source);\n                if (mappedSource) {\n                    sourceCache[loc.source] = mappedSource;\n                }\n\n                resolve(\n                    // given stackframe and source location, update stackframe\n                    new StackFrame({\n                        functionName: loc.name || stackframe.functionName,\n                        args: stackframe.args,\n                        fileName: loc.source,\n                        lineNumber: loc.line,\n                        columnNumber: loc.column\n                    }));\n            } else {\n                reject(new Error('Could not get original source for given stackframe and source map'));\n            }\n        });\n    }\n\n    /**\n     * @constructor\n     * @param {Object} opts\n     *      opts.sourceCache = {url: \"Source String\"} => preload source cache\n     *      opts.sourceMapConsumerCache = {/path/file.js.map: SourceMapConsumer}\n     *      opts.offline = True to prevent network requests.\n     *              Best effort without sources or source maps.\n     *      opts.ajax = Promise returning function to make X-Domain requests\n     */\n    return function StackTraceGPS(opts) {\n        if (!(this instanceof StackTraceGPS)) {\n            return new StackTraceGPS(opts);\n        }\n        opts = opts || {};\n\n        this.sourceCache = opts.sourceCache || {};\n        this.sourceMapConsumerCache = opts.sourceMapConsumerCache || {};\n\n        this.ajax = opts.ajax || _xdr;\n\n        this._atob = opts.atob || _atob;\n\n        this._get = function _get(location) {\n            return new Promise(function(resolve, reject) {\n                var isDataUrl = location.substr(0, 5) === 'data:';\n                if (this.sourceCache[location]) {\n                    resolve(this.sourceCache[location]);\n                } else if (opts.offline && !isDataUrl) {\n                    reject(new Error('Cannot make network requests in offline mode'));\n                } else {\n                    if (isDataUrl) {\n                        // data URLs can have parameters.\n                        // see http://tools.ietf.org/html/rfc2397\n                        var supportedEncodingRegexp =\n                            /^data:application\\/json;([\\w=:\"-]+;)*base64,/;\n                        var match = location.match(supportedEncodingRegexp);\n                        if (match) {\n                            var sourceMapStart = match[0].length;\n                            var encodedSource = location.substr(sourceMapStart);\n                            var source = this._atob(encodedSource);\n                            this.sourceCache[location] = source;\n                            resolve(source);\n                        } else {\n                            reject(new Error('The encoding of the inline sourcemap is not supported'));\n                        }\n                    } else {\n                        var xhrPromise = this.ajax(location, {method: 'get'});\n                        // Cache the Promise to prevent duplicate in-flight requests\n                        this.sourceCache[location] = xhrPromise;\n                        xhrPromise.then(resolve, reject);\n                    }\n                }\n            }.bind(this));\n        };\n\n        /**\n         * Creating SourceMapConsumers is expensive, so this wraps the creation of a\n         * SourceMapConsumer in a per-instance cache.\n         *\n         * @param {String} sourceMappingURL = URL to fetch source map from\n         * @param {String} defaultSourceRoot = Default source root for source map if undefined\n         * @returns {Promise} that resolves a SourceMapConsumer\n         */\n        this._getSourceMapConsumer = function _getSourceMapConsumer(sourceMappingURL, defaultSourceRoot) {\n            return new Promise(function(resolve) {\n                if (this.sourceMapConsumerCache[sourceMappingURL]) {\n                    resolve(this.sourceMapConsumerCache[sourceMappingURL]);\n                } else {\n                    var sourceMapConsumerPromise = new Promise(function(resolve, reject) {\n                        return this._get(sourceMappingURL).then(function(sourceMapSource) {\n                            if (typeof sourceMapSource === 'string') {\n                                sourceMapSource = _parseJson(sourceMapSource.replace(/^\\)\\]\\}'/, ''));\n                            }\n                            if (typeof sourceMapSource.sourceRoot === 'undefined') {\n                                sourceMapSource.sourceRoot = defaultSourceRoot;\n                            }\n\n                            resolve(new SourceMap.SourceMapConsumer(sourceMapSource));\n                        }).catch(reject);\n                    }.bind(this));\n                    this.sourceMapConsumerCache[sourceMappingURL] = sourceMapConsumerPromise;\n                    resolve(sourceMapConsumerPromise);\n                }\n            }.bind(this));\n        };\n\n        /**\n         * Given a StackFrame, enhance function name and use source maps for a\n         * better StackFrame.\n         *\n         * @param {StackFrame} stackframe object\n         * @returns {Promise} that resolves with with source-mapped StackFrame\n         */\n        this.pinpoint = function StackTraceGPS$$pinpoint(stackframe) {\n            return new Promise(function(resolve, reject) {\n                this.getMappedLocation(stackframe).then(function(mappedStackFrame) {\n                    function resolveMappedStackFrame() {\n                        resolve(mappedStackFrame);\n                    }\n\n                    this.findFunctionName(mappedStackFrame)\n                        .then(resolve, resolveMappedStackFrame)\n                        // eslint-disable-next-line no-unexpected-multiline\n                        ['catch'](resolveMappedStackFrame);\n                }.bind(this), reject);\n            }.bind(this));\n        };\n\n        /**\n         * Given a StackFrame, guess function name from location information.\n         *\n         * @param {StackFrame} stackframe\n         * @returns {Promise} that resolves with enhanced StackFrame.\n         */\n        this.findFunctionName = function StackTraceGPS$$findFunctionName(stackframe) {\n            return new Promise(function(resolve, reject) {\n                _ensureStackFrameIsLegit(stackframe);\n                this._get(stackframe.fileName).then(function getSourceCallback(source) {\n                    var lineNumber = stackframe.lineNumber;\n                    var columnNumber = stackframe.columnNumber;\n                    var guessedFunctionName = _findFunctionName(source, lineNumber, columnNumber);\n                    // Only replace functionName if we found something\n                    if (guessedFunctionName) {\n                        resolve(new StackFrame({\n                            functionName: guessedFunctionName,\n                            args: stackframe.args,\n                            fileName: stackframe.fileName,\n                            lineNumber: lineNumber,\n                            columnNumber: columnNumber\n                        }));\n                    } else {\n                        resolve(stackframe);\n                    }\n                }, reject)['catch'](reject);\n            }.bind(this));\n        };\n\n        /**\n         * Given a StackFrame, seek source-mapped location and return new enhanced StackFrame.\n         *\n         * @param {StackFrame} stackframe\n         * @returns {Promise} that resolves with enhanced StackFrame.\n         */\n        this.getMappedLocation = function StackTraceGPS$$getMappedLocation(stackframe) {\n            return new Promise(function(resolve, reject) {\n                _ensureSupportedEnvironment();\n                _ensureStackFrameIsLegit(stackframe);\n\n                var sourceCache = this.sourceCache;\n                var fileName = stackframe.fileName;\n                this._get(fileName).then(function(source) {\n                    var sourceMappingURL = _findSourceMappingURL(source);\n                    var isDataUrl = sourceMappingURL.substr(0, 5) === 'data:';\n                    var defaultSourceRoot = fileName.substring(0, fileName.lastIndexOf('/') + 1);\n\n                    if (sourceMappingURL[0] !== '/' && !isDataUrl && !(/^https?:\\/\\/|^\\/\\//i).test(sourceMappingURL)) {\n                        sourceMappingURL = defaultSourceRoot + sourceMappingURL;\n                    }\n\n                    return this._getSourceMapConsumer(sourceMappingURL, defaultSourceRoot)\n                        .then(function(sourceMapConsumer) {\n                            return _extractLocationInfoFromSourceMapSource(stackframe, sourceMapConsumer, sourceCache)\n                                .then(resolve)['catch'](function() {\n                                    resolve(stackframe);\n                                });\n                        });\n                }.bind(this), reject)['catch'](reject);\n            }.bind(this));\n        };\n    };\n}));\n","(function(root, factory) {\n    'use strict';\n    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.\n\n    /* istanbul ignore next */\n    if (typeof define === 'function' && define.amd) {\n        define('stacktrace', ['error-stack-parser', 'stack-generator', 'stacktrace-gps'], factory);\n    } else if (typeof exports === 'object') {\n        module.exports = factory(require('error-stack-parser'), require('stack-generator'), require('stacktrace-gps'));\n    } else {\n        root.StackTrace = factory(root.ErrorStackParser, root.StackGenerator, root.StackTraceGPS);\n    }\n}(this, function StackTrace(ErrorStackParser, StackGenerator, StackTraceGPS) {\n    var _options = {\n        filter: function(stackframe) {\n            // Filter out stackframes for this library by default\n            return (stackframe.functionName || '').indexOf('StackTrace$$') === -1 &&\n                (stackframe.functionName || '').indexOf('ErrorStackParser$$') === -1 &&\n                (stackframe.functionName || '').indexOf('StackTraceGPS$$') === -1 &&\n                (stackframe.functionName || '').indexOf('StackGenerator$$') === -1;\n        },\n        sourceCache: {}\n    };\n\n    var _generateError = function StackTrace$$GenerateError() {\n        try {\n            // Error must be thrown to get stack in IE\n            throw new Error();\n        } catch (err) {\n            return err;\n        }\n    };\n\n    /**\n     * Merge 2 given Objects. If a conflict occurs the second object wins.\n     * Does not do deep merges.\n     *\n     * @param {Object} first base object\n     * @param {Object} second overrides\n     * @returns {Object} merged first and second\n     * @private\n     */\n    function _merge(first, second) {\n        var target = {};\n\n        [first, second].forEach(function(obj) {\n            for (var prop in obj) {\n                if (Object.prototype.hasOwnProperty.call(obj, prop)) {\n                    target[prop] = obj[prop];\n                }\n            }\n            return target;\n        });\n\n        return target;\n    }\n\n    function _isShapedLikeParsableError(err) {\n        return err.stack || err['opera#sourceloc'];\n    }\n\n    function _filtered(stackframes, filter) {\n        if (typeof filter === 'function') {\n            return stackframes.filter(filter);\n        }\n        return stackframes;\n    }\n\n    return {\n        /**\n         * Get a backtrace from invocation point.\n         *\n         * @param {Object} opts\n         * @returns {Array} of StackFrame\n         */\n        get: function StackTrace$$get(opts) {\n            var err = _generateError();\n            return _isShapedLikeParsableError(err) ? this.fromError(err, opts) : this.generateArtificially(opts);\n        },\n\n        /**\n         * Get a backtrace from invocation point.\n         * IMPORTANT: Does not handle source maps or guess function names!\n         *\n         * @param {Object} opts\n         * @returns {Array} of StackFrame\n         */\n        getSync: function StackTrace$$getSync(opts) {\n            opts = _merge(_options, opts);\n            var err = _generateError();\n            var stack = _isShapedLikeParsableError(err) ? ErrorStackParser.parse(err) : StackGenerator.backtrace(opts);\n            return _filtered(stack, opts.filter);\n        },\n\n        /**\n         * Given an error object, parse it.\n         *\n         * @param {Error} error object\n         * @param {Object} opts\n         * @returns {Promise} for Array[StackFrame}\n         */\n        fromError: function StackTrace$$fromError(error, opts) {\n            opts = _merge(_options, opts);\n            var gps = new StackTraceGPS(opts);\n            return new Promise(function(resolve) {\n                var stackframes = _filtered(ErrorStackParser.parse(error), opts.filter);\n                resolve(Promise.all(stackframes.map(function(sf) {\n                    return new Promise(function(resolve) {\n                        function resolveOriginal() {\n                            resolve(sf);\n                        }\n\n                        gps.pinpoint(sf).then(resolve, resolveOriginal)['catch'](resolveOriginal);\n                    });\n                })));\n            }.bind(this));\n        },\n\n        /**\n         * Use StackGenerator to generate a backtrace.\n         *\n         * @param {Object} opts\n         * @returns {Promise} of Array[StackFrame]\n         */\n        generateArtificially: function StackTrace$$generateArtificially(opts) {\n            opts = _merge(_options, opts);\n            var stackFrames = StackGenerator.backtrace(opts);\n            if (typeof opts.filter === 'function') {\n                stackFrames = stackFrames.filter(opts.filter);\n            }\n            return Promise.resolve(stackFrames);\n        },\n\n        /**\n         * Given a function, wrap it such that invocations trigger a callback that\n         * is called with a stack trace.\n         *\n         * @param {Function} fn to be instrumented\n         * @param {Function} callback function to call with a stack trace on invocation\n         * @param {Function} errback optional function to call with error if unable to get stack trace.\n         * @param {Object} thisArg optional context object (e.g. window)\n         */\n        instrument: function StackTrace$$instrument(fn, callback, errback, thisArg) {\n            if (typeof fn !== 'function') {\n                throw new Error('Cannot instrument non-function object');\n            } else if (typeof fn.__stacktraceOriginalFn === 'function') {\n                // Already instrumented, return given Function\n                return fn;\n            }\n\n            var instrumented = function StackTrace$$instrumented() {\n                try {\n                    this.get().then(callback, errback)['catch'](errback);\n                    return fn.apply(thisArg || this, arguments);\n                } catch (e) {\n                    if (_isShapedLikeParsableError(e)) {\n                        this.fromError(e).then(callback, errback)['catch'](errback);\n                    }\n                    throw e;\n                }\n            }.bind(this);\n            instrumented.__stacktraceOriginalFn = fn;\n\n            return instrumented;\n        },\n\n        /**\n         * Given a function that has been instrumented,\n         * revert the function to it's original (non-instrumented) state.\n         *\n         * @param {Function} fn to de-instrument\n         */\n        deinstrument: function StackTrace$$deinstrument(fn) {\n            if (typeof fn !== 'function') {\n                throw new Error('Cannot de-instrument non-function object');\n            } else if (typeof fn.__stacktraceOriginalFn === 'function') {\n                return fn.__stacktraceOriginalFn;\n            } else {\n                // Function not instrumented, return original\n                return fn;\n            }\n        },\n\n        /**\n         * Given an error message and Array of StackFrames, serialize and POST to given URL.\n         *\n         * @param {Array} stackframes\n         * @param {String} url\n         * @param {String} errorMsg\n         * @param {Object} requestOptions\n         */\n        report: function StackTrace$$report(stackframes, url, errorMsg, requestOptions) {\n            return new Promise(function(resolve, reject) {\n                var req = new XMLHttpRequest();\n                req.onerror = reject;\n                req.onreadystatechange = function onreadystatechange() {\n                    if (req.readyState === 4) {\n                        if (req.status >= 200 && req.status < 400) {\n                            resolve(req.responseText);\n                        } else {\n                            reject(new Error('POST to ' + url + ' failed with status: ' + req.status));\n                        }\n                    }\n                };\n                req.open('post', url);\n\n                // Set request headers\n                req.setRequestHeader('Content-Type', 'application/json');\n                if (requestOptions && typeof requestOptions.headers === 'object') {\n                    var headers = requestOptions.headers;\n                    for (var header in headers) {\n                        if (Object.prototype.hasOwnProperty.call(headers, header)) {\n                            req.setRequestHeader(header, headers[header]);\n                        }\n                    }\n                }\n\n                var reportPayload = {stack: stackframes};\n                if (errorMsg !== undefined && errorMsg !== null) {\n                    reportPayload.message = errorMsg;\n                }\n\n                req.send(JSON.stringify(reportPayload));\n            });\n        }\n    };\n}));\n"],"names":["SourceMap","StackFrame","_xdr","url","Promise","resolve","reject","req","XMLHttpRequest","open","onerror","onreadystatechange","readyState","status","substr","responseText","Error","send","_atob","b64str","window","atob","_parseJson","string","JSON","parse","_findFunctionName","source","lineNumber","syntaxes","lines","split","code","maxLines","Math","min","i","line","commentPos","indexOf","len","length","index","m","exec","_ensureSupportedEnvironment","Object","defineProperty","create","_ensureStackFrameIsLegit","stackframe","TypeError","fileName","columnNumber","_findSourceMappingURL","lastSourceMappingUrl","matchSourceMappingUrl","sourceMappingUrlRegExp","_extractLocationInfoFromSourceMapSource","sourceMapConsumer","sourceCache","loc","originalPositionFor","column","mappedSource","sourceContentFor","functionName","name","args","StackTraceGPS","opts","this","sourceMapConsumerCache","ajax","_get","location","isDataUrl","offline","supportedEncodingRegexp","match","sourceMapStart","encodedSource","xhrPromise","method","then","bind","_getSourceMapConsumer","sourceMappingURL","defaultSourceRoot","sourceMapConsumerPromise","sourceMapSource","replace","sourceRoot","SourceMapConsumer","catch","pinpoint","getMappedLocation","mappedStackFrame","resolveMappedStackFrame","findFunctionName","guessedFunctionName","substring","lastIndexOf","test","ErrorStackParser","StackGenerator","_options","filter","_generateError","err","_merge","first","second","target","forEach","obj","prop","prototype","hasOwnProperty","call","_isShapedLikeParsableError","stack","_filtered","stackframes","get","fromError","generateArtificially","getSync","backtrace","error","gps","all","map","sf","resolveOriginal","stackFrames","instrument","fn","callback","errback","thisArg","__stacktraceOriginalFn","instrumented","apply","arguments","e","deinstrument","report","errorMsg","requestOptions","setRequestHeader","headers","header","reportPayload","message","stringify"],"sourceRoot":""}