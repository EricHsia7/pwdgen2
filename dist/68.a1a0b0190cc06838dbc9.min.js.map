{"version":3,"file":"68.a1a0b0190cc06838dbc9.min.js","mappings":"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","sources":["webpack://pwdgen2/./node_modules/stacktrace-gps/node_modules/source-map/lib/quick-sort.js","webpack://pwdgen2/./node_modules/stacktrace-gps/node_modules/source-map/lib/source-map-generator.js","webpack://pwdgen2/./node_modules/stacktrace-gps/node_modules/source-map/lib/source-node.js"],"sourcesContent":["/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\n// It turns out that some (most?) JavaScript engines don't self-host\n// `Array.prototype.sort`. This makes sense because C++ will likely remain\n// faster than JS when doing raw CPU-intensive sorting. However, when using a\n// custom comparator function, calling back and forth between the VM's C++ and\n// JIT'd JS is rather slow *and* loses JIT type information, resulting in\n// worse generated code for the comparator function than would be optimal. In\n// fact, when sorting with a comparator, these costs outweigh the benefits of\n// sorting in C++. By using our own JS-implemented Quick Sort (below), we get\n// a ~3500ms mean speed-up in `bench/bench.html`.\n\n/**\n * Swap the elements indexed by `x` and `y` in the array `ary`.\n *\n * @param {Array} ary\n *        The array.\n * @param {Number} x\n *        The index of the first item.\n * @param {Number} y\n *        The index of the second item.\n */\nfunction swap(ary, x, y) {\n  var temp = ary[x];\n  ary[x] = ary[y];\n  ary[y] = temp;\n}\n\n/**\n * Returns a random integer within the range `low .. high` inclusive.\n *\n * @param {Number} low\n *        The lower bound on the range.\n * @param {Number} high\n *        The upper bound on the range.\n */\nfunction randomIntInRange(low, high) {\n  return Math.round(low + (Math.random() * (high - low)));\n}\n\n/**\n * The Quick Sort algorithm.\n *\n * @param {Array} ary\n *        An array to sort.\n * @param {function} comparator\n *        Function to use to compare two items.\n * @param {Number} p\n *        Start index of the array\n * @param {Number} r\n *        End index of the array\n */\nfunction doQuickSort(ary, comparator, p, r) {\n  // If our lower bound is less than our upper bound, we (1) partition the\n  // array into two pieces and (2) recurse on each half. If it is not, this is\n  // the empty array and our base case.\n\n  if (p < r) {\n    // (1) Partitioning.\n    //\n    // The partitioning chooses a pivot between `p` and `r` and moves all\n    // elements that are less than or equal to the pivot to the before it, and\n    // all the elements that are greater than it after it. The effect is that\n    // once partition is done, the pivot is in the exact place it will be when\n    // the array is put in sorted order, and it will not need to be moved\n    // again. This runs in O(n) time.\n\n    // Always choose a random pivot so that an input array which is reverse\n    // sorted does not cause O(n^2) running time.\n    var pivotIndex = randomIntInRange(p, r);\n    var i = p - 1;\n\n    swap(ary, pivotIndex, r);\n    var pivot = ary[r];\n\n    // Immediately after `j` is incremented in this loop, the following hold\n    // true:\n    //\n    //   * Every element in `ary[p .. i]` is less than or equal to the pivot.\n    //\n    //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.\n    for (var j = p; j < r; j++) {\n      if (comparator(ary[j], pivot) <= 0) {\n        i += 1;\n        swap(ary, i, j);\n      }\n    }\n\n    swap(ary, i + 1, j);\n    var q = i + 1;\n\n    // (2) Recurse on each half.\n\n    doQuickSort(ary, comparator, p, q - 1);\n    doQuickSort(ary, comparator, q + 1, r);\n  }\n}\n\n/**\n * Sort the given array in-place with the given comparator function.\n *\n * @param {Array} ary\n *        An array to sort.\n * @param {function} comparator\n *        Function to use to compare two items.\n */\nexports.quickSort = function (ary, comparator) {\n  doQuickSort(ary, comparator, 0, ary.length - 1);\n};\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar base64VLQ = require('./base64-vlq');\nvar util = require('./util');\nvar ArraySet = require('./array-set').ArraySet;\nvar MappingList = require('./mapping-list').MappingList;\n\n/**\n * An instance of the SourceMapGenerator represents a source map which is\n * being built incrementally. You may pass an object with the following\n * properties:\n *\n *   - file: The filename of the generated source.\n *   - sourceRoot: A root for all relative URLs in this source map.\n */\nfunction SourceMapGenerator(aArgs) {\n  if (!aArgs) {\n    aArgs = {};\n  }\n  this._file = util.getArg(aArgs, 'file', null);\n  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);\n  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);\n  this._sources = new ArraySet();\n  this._names = new ArraySet();\n  this._mappings = new MappingList();\n  this._sourcesContents = null;\n}\n\nSourceMapGenerator.prototype._version = 3;\n\n/**\n * Creates a new SourceMapGenerator based on a SourceMapConsumer\n *\n * @param aSourceMapConsumer The SourceMap.\n */\nSourceMapGenerator.fromSourceMap =\n  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {\n    var sourceRoot = aSourceMapConsumer.sourceRoot;\n    var generator = new SourceMapGenerator({\n      file: aSourceMapConsumer.file,\n      sourceRoot: sourceRoot\n    });\n    aSourceMapConsumer.eachMapping(function (mapping) {\n      var newMapping = {\n        generated: {\n          line: mapping.generatedLine,\n          column: mapping.generatedColumn\n        }\n      };\n\n      if (mapping.source != null) {\n        newMapping.source = mapping.source;\n        if (sourceRoot != null) {\n          newMapping.source = util.relative(sourceRoot, newMapping.source);\n        }\n\n        newMapping.original = {\n          line: mapping.originalLine,\n          column: mapping.originalColumn\n        };\n\n        if (mapping.name != null) {\n          newMapping.name = mapping.name;\n        }\n      }\n\n      generator.addMapping(newMapping);\n    });\n    aSourceMapConsumer.sources.forEach(function (sourceFile) {\n      var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n      if (content != null) {\n        generator.setSourceContent(sourceFile, content);\n      }\n    });\n    return generator;\n  };\n\n/**\n * Add a single mapping from original source line and column to the generated\n * source's line and column for this source map being created. The mapping\n * object should have the following properties:\n *\n *   - generated: An object with the generated line and column positions.\n *   - original: An object with the original line and column positions.\n *   - source: The original source file (relative to the sourceRoot).\n *   - name: An optional original token name for this mapping.\n */\nSourceMapGenerator.prototype.addMapping =\n  function SourceMapGenerator_addMapping(aArgs) {\n    var generated = util.getArg(aArgs, 'generated');\n    var original = util.getArg(aArgs, 'original', null);\n    var source = util.getArg(aArgs, 'source', null);\n    var name = util.getArg(aArgs, 'name', null);\n\n    if (!this._skipValidation) {\n      this._validateMapping(generated, original, source, name);\n    }\n\n    if (source != null) {\n      source = String(source);\n      if (!this._sources.has(source)) {\n        this._sources.add(source);\n      }\n    }\n\n    if (name != null) {\n      name = String(name);\n      if (!this._names.has(name)) {\n        this._names.add(name);\n      }\n    }\n\n    this._mappings.add({\n      generatedLine: generated.line,\n      generatedColumn: generated.column,\n      originalLine: original != null && original.line,\n      originalColumn: original != null && original.column,\n      source: source,\n      name: name\n    });\n  };\n\n/**\n * Set the source content for a source file.\n */\nSourceMapGenerator.prototype.setSourceContent =\n  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {\n    var source = aSourceFile;\n    if (this._sourceRoot != null) {\n      source = util.relative(this._sourceRoot, source);\n    }\n\n    if (aSourceContent != null) {\n      // Add the source content to the _sourcesContents map.\n      // Create a new _sourcesContents map if the property is null.\n      if (!this._sourcesContents) {\n        this._sourcesContents = Object.create(null);\n      }\n      this._sourcesContents[util.toSetString(source)] = aSourceContent;\n    } else if (this._sourcesContents) {\n      // Remove the source file from the _sourcesContents map.\n      // If the _sourcesContents map is empty, set the property to null.\n      delete this._sourcesContents[util.toSetString(source)];\n      if (Object.keys(this._sourcesContents).length === 0) {\n        this._sourcesContents = null;\n      }\n    }\n  };\n\n/**\n * Applies the mappings of a sub-source-map for a specific source file to the\n * source map being generated. Each mapping to the supplied source file is\n * rewritten using the supplied source map. Note: The resolution for the\n * resulting mappings is the minimium of this map and the supplied map.\n *\n * @param aSourceMapConsumer The source map to be applied.\n * @param aSourceFile Optional. The filename of the source file.\n *        If omitted, SourceMapConsumer's file property will be used.\n * @param aSourceMapPath Optional. The dirname of the path to the source map\n *        to be applied. If relative, it is relative to the SourceMapConsumer.\n *        This parameter is needed when the two source maps aren't in the same\n *        directory, and the source map to be applied contains relative source\n *        paths. If so, those relative source paths need to be rewritten\n *        relative to the SourceMapGenerator.\n */\nSourceMapGenerator.prototype.applySourceMap =\n  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {\n    var sourceFile = aSourceFile;\n    // If aSourceFile is omitted, we will use the file property of the SourceMap\n    if (aSourceFile == null) {\n      if (aSourceMapConsumer.file == null) {\n        throw new Error(\n          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +\n          'or the source map\\'s \"file\" property. Both were omitted.'\n        );\n      }\n      sourceFile = aSourceMapConsumer.file;\n    }\n    var sourceRoot = this._sourceRoot;\n    // Make \"sourceFile\" relative if an absolute Url is passed.\n    if (sourceRoot != null) {\n      sourceFile = util.relative(sourceRoot, sourceFile);\n    }\n    // Applying the SourceMap can add and remove items from the sources and\n    // the names array.\n    var newSources = new ArraySet();\n    var newNames = new ArraySet();\n\n    // Find mappings for the \"sourceFile\"\n    this._mappings.unsortedForEach(function (mapping) {\n      if (mapping.source === sourceFile && mapping.originalLine != null) {\n        // Check if it can be mapped by the source map, then update the mapping.\n        var original = aSourceMapConsumer.originalPositionFor({\n          line: mapping.originalLine,\n          column: mapping.originalColumn\n        });\n        if (original.source != null) {\n          // Copy mapping\n          mapping.source = original.source;\n          if (aSourceMapPath != null) {\n            mapping.source = util.join(aSourceMapPath, mapping.source)\n          }\n          if (sourceRoot != null) {\n            mapping.source = util.relative(sourceRoot, mapping.source);\n          }\n          mapping.originalLine = original.line;\n          mapping.originalColumn = original.column;\n          if (original.name != null) {\n            mapping.name = original.name;\n          }\n        }\n      }\n\n      var source = mapping.source;\n      if (source != null && !newSources.has(source)) {\n        newSources.add(source);\n      }\n\n      var name = mapping.name;\n      if (name != null && !newNames.has(name)) {\n        newNames.add(name);\n      }\n\n    }, this);\n    this._sources = newSources;\n    this._names = newNames;\n\n    // Copy sourcesContents of applied map.\n    aSourceMapConsumer.sources.forEach(function (sourceFile) {\n      var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n      if (content != null) {\n        if (aSourceMapPath != null) {\n          sourceFile = util.join(aSourceMapPath, sourceFile);\n        }\n        if (sourceRoot != null) {\n          sourceFile = util.relative(sourceRoot, sourceFile);\n        }\n        this.setSourceContent(sourceFile, content);\n      }\n    }, this);\n  };\n\n/**\n * A mapping can have one of the three levels of data:\n *\n *   1. Just the generated position.\n *   2. The Generated position, original position, and original source.\n *   3. Generated and original position, original source, as well as a name\n *      token.\n *\n * To maintain consistency, we validate that any new mapping being added falls\n * in to one of these categories.\n */\nSourceMapGenerator.prototype._validateMapping =\n  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,\n                                              aName) {\n    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated\n        && aGenerated.line > 0 && aGenerated.column >= 0\n        && !aOriginal && !aSource && !aName) {\n      // Case 1.\n      return;\n    }\n    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated\n             && aOriginal && 'line' in aOriginal && 'column' in aOriginal\n             && aGenerated.line > 0 && aGenerated.column >= 0\n             && aOriginal.line > 0 && aOriginal.column >= 0\n             && aSource) {\n      // Cases 2 and 3.\n      return;\n    }\n    else {\n      throw new Error('Invalid mapping: ' + JSON.stringify({\n        generated: aGenerated,\n        source: aSource,\n        original: aOriginal,\n        name: aName\n      }));\n    }\n  };\n\n/**\n * Serialize the accumulated mappings in to the stream of base 64 VLQs\n * specified by the source map format.\n */\nSourceMapGenerator.prototype._serializeMappings =\n  function SourceMapGenerator_serializeMappings() {\n    var previousGeneratedColumn = 0;\n    var previousGeneratedLine = 1;\n    var previousOriginalColumn = 0;\n    var previousOriginalLine = 0;\n    var previousName = 0;\n    var previousSource = 0;\n    var result = '';\n    var next;\n    var mapping;\n    var nameIdx;\n    var sourceIdx;\n\n    var mappings = this._mappings.toArray();\n    for (var i = 0, len = mappings.length; i < len; i++) {\n      mapping = mappings[i];\n      next = ''\n\n      if (mapping.generatedLine !== previousGeneratedLine) {\n        previousGeneratedColumn = 0;\n        while (mapping.generatedLine !== previousGeneratedLine) {\n          next += ';';\n          previousGeneratedLine++;\n        }\n      }\n      else {\n        if (i > 0) {\n          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {\n            continue;\n          }\n          next += ',';\n        }\n      }\n\n      next += base64VLQ.encode(mapping.generatedColumn\n                                 - previousGeneratedColumn);\n      previousGeneratedColumn = mapping.generatedColumn;\n\n      if (mapping.source != null) {\n        sourceIdx = this._sources.indexOf(mapping.source);\n        next += base64VLQ.encode(sourceIdx - previousSource);\n        previousSource = sourceIdx;\n\n        // lines are stored 0-based in SourceMap spec version 3\n        next += base64VLQ.encode(mapping.originalLine - 1\n                                   - previousOriginalLine);\n        previousOriginalLine = mapping.originalLine - 1;\n\n        next += base64VLQ.encode(mapping.originalColumn\n                                   - previousOriginalColumn);\n        previousOriginalColumn = mapping.originalColumn;\n\n        if (mapping.name != null) {\n          nameIdx = this._names.indexOf(mapping.name);\n          next += base64VLQ.encode(nameIdx - previousName);\n          previousName = nameIdx;\n        }\n      }\n\n      result += next;\n    }\n\n    return result;\n  };\n\nSourceMapGenerator.prototype._generateSourcesContent =\n  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {\n    return aSources.map(function (source) {\n      if (!this._sourcesContents) {\n        return null;\n      }\n      if (aSourceRoot != null) {\n        source = util.relative(aSourceRoot, source);\n      }\n      var key = util.toSetString(source);\n      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)\n        ? this._sourcesContents[key]\n        : null;\n    }, this);\n  };\n\n/**\n * Externalize the source map.\n */\nSourceMapGenerator.prototype.toJSON =\n  function SourceMapGenerator_toJSON() {\n    var map = {\n      version: this._version,\n      sources: this._sources.toArray(),\n      names: this._names.toArray(),\n      mappings: this._serializeMappings()\n    };\n    if (this._file != null) {\n      map.file = this._file;\n    }\n    if (this._sourceRoot != null) {\n      map.sourceRoot = this._sourceRoot;\n    }\n    if (this._sourcesContents) {\n      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);\n    }\n\n    return map;\n  };\n\n/**\n * Render the source map being generated to a string.\n */\nSourceMapGenerator.prototype.toString =\n  function SourceMapGenerator_toString() {\n    return JSON.stringify(this.toJSON());\n  };\n\nexports.SourceMapGenerator = SourceMapGenerator;\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar SourceMapGenerator = require('./source-map-generator').SourceMapGenerator;\nvar util = require('./util');\n\n// Matches a Windows-style `\\r\\n` newline or a `\\n` newline used by all other\n// operating systems these days (capturing the result).\nvar REGEX_NEWLINE = /(\\r?\\n)/;\n\n// Newline character code for charCodeAt() comparisons\nvar NEWLINE_CODE = 10;\n\n// Private symbol for identifying `SourceNode`s when multiple versions of\n// the source-map library are loaded. This MUST NOT CHANGE across\n// versions!\nvar isSourceNode = \"$$$isSourceNode$$$\";\n\n/**\n * SourceNodes provide a way to abstract over interpolating/concatenating\n * snippets of generated JavaScript source code while maintaining the line and\n * column information associated with the original source code.\n *\n * @param aLine The original line number.\n * @param aColumn The original column number.\n * @param aSource The original source's filename.\n * @param aChunks Optional. An array of strings which are snippets of\n *        generated JS, or other SourceNodes.\n * @param aName The original identifier.\n */\nfunction SourceNode(aLine, aColumn, aSource, aChunks, aName) {\n  this.children = [];\n  this.sourceContents = {};\n  this.line = aLine == null ? null : aLine;\n  this.column = aColumn == null ? null : aColumn;\n  this.source = aSource == null ? null : aSource;\n  this.name = aName == null ? null : aName;\n  this[isSourceNode] = true;\n  if (aChunks != null) this.add(aChunks);\n}\n\n/**\n * Creates a SourceNode from generated code and a SourceMapConsumer.\n *\n * @param aGeneratedCode The generated code\n * @param aSourceMapConsumer The SourceMap for the generated code\n * @param aRelativePath Optional. The path that relative sources in the\n *        SourceMapConsumer should be relative to.\n */\nSourceNode.fromStringWithSourceMap =\n  function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {\n    // The SourceNode we want to fill with the generated code\n    // and the SourceMap\n    var node = new SourceNode();\n\n    // All even indices of this array are one line of the generated code,\n    // while all odd indices are the newlines between two adjacent lines\n    // (since `REGEX_NEWLINE` captures its match).\n    // Processed fragments are removed from this array, by calling `shiftNextLine`.\n    var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);\n    var shiftNextLine = function() {\n      var lineContents = remainingLines.shift();\n      // The last line of a file might not have a newline.\n      var newLine = remainingLines.shift() || \"\";\n      return lineContents + newLine;\n    };\n\n    // We need to remember the position of \"remainingLines\"\n    var lastGeneratedLine = 1, lastGeneratedColumn = 0;\n\n    // The generate SourceNodes we need a code range.\n    // To extract it current and last mapping is used.\n    // Here we store the last mapping.\n    var lastMapping = null;\n\n    aSourceMapConsumer.eachMapping(function (mapping) {\n      if (lastMapping !== null) {\n        // We add the code from \"lastMapping\" to \"mapping\":\n        // First check if there is a new line in between.\n        if (lastGeneratedLine < mapping.generatedLine) {\n          // Associate first line with \"lastMapping\"\n          addMappingWithCode(lastMapping, shiftNextLine());\n          lastGeneratedLine++;\n          lastGeneratedColumn = 0;\n          // The remaining code is added without mapping\n        } else {\n          // There is no new line in between.\n          // Associate the code between \"lastGeneratedColumn\" and\n          // \"mapping.generatedColumn\" with \"lastMapping\"\n          var nextLine = remainingLines[0];\n          var code = nextLine.substr(0, mapping.generatedColumn -\n                                        lastGeneratedColumn);\n          remainingLines[0] = nextLine.substr(mapping.generatedColumn -\n                                              lastGeneratedColumn);\n          lastGeneratedColumn = mapping.generatedColumn;\n          addMappingWithCode(lastMapping, code);\n          // No more remaining code, continue\n          lastMapping = mapping;\n          return;\n        }\n      }\n      // We add the generated code until the first mapping\n      // to the SourceNode without any mapping.\n      // Each line is added as separate string.\n      while (lastGeneratedLine < mapping.generatedLine) {\n        node.add(shiftNextLine());\n        lastGeneratedLine++;\n      }\n      if (lastGeneratedColumn < mapping.generatedColumn) {\n        var nextLine = remainingLines[0];\n        node.add(nextLine.substr(0, mapping.generatedColumn));\n        remainingLines[0] = nextLine.substr(mapping.generatedColumn);\n        lastGeneratedColumn = mapping.generatedColumn;\n      }\n      lastMapping = mapping;\n    }, this);\n    // We have processed all mappings.\n    if (remainingLines.length > 0) {\n      if (lastMapping) {\n        // Associate the remaining code in the current line with \"lastMapping\"\n        addMappingWithCode(lastMapping, shiftNextLine());\n      }\n      // and add the remaining lines without any mapping\n      node.add(remainingLines.join(\"\"));\n    }\n\n    // Copy sourcesContent into SourceNode\n    aSourceMapConsumer.sources.forEach(function (sourceFile) {\n      var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n      if (content != null) {\n        if (aRelativePath != null) {\n          sourceFile = util.join(aRelativePath, sourceFile);\n        }\n        node.setSourceContent(sourceFile, content);\n      }\n    });\n\n    return node;\n\n    function addMappingWithCode(mapping, code) {\n      if (mapping === null || mapping.source === undefined) {\n        node.add(code);\n      } else {\n        var source = aRelativePath\n          ? util.join(aRelativePath, mapping.source)\n          : mapping.source;\n        node.add(new SourceNode(mapping.originalLine,\n                                mapping.originalColumn,\n                                source,\n                                code,\n                                mapping.name));\n      }\n    }\n  };\n\n/**\n * Add a chunk of generated JS to this source node.\n *\n * @param aChunk A string snippet of generated JS code, another instance of\n *        SourceNode, or an array where each member is one of those things.\n */\nSourceNode.prototype.add = function SourceNode_add(aChunk) {\n  if (Array.isArray(aChunk)) {\n    aChunk.forEach(function (chunk) {\n      this.add(chunk);\n    }, this);\n  }\n  else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\n    if (aChunk) {\n      this.children.push(aChunk);\n    }\n  }\n  else {\n    throw new TypeError(\n      \"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk\n    );\n  }\n  return this;\n};\n\n/**\n * Add a chunk of generated JS to the beginning of this source node.\n *\n * @param aChunk A string snippet of generated JS code, another instance of\n *        SourceNode, or an array where each member is one of those things.\n */\nSourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {\n  if (Array.isArray(aChunk)) {\n    for (var i = aChunk.length-1; i >= 0; i--) {\n      this.prepend(aChunk[i]);\n    }\n  }\n  else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\n    this.children.unshift(aChunk);\n  }\n  else {\n    throw new TypeError(\n      \"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk\n    );\n  }\n  return this;\n};\n\n/**\n * Walk over the tree of JS snippets in this node and its children. The\n * walking function is called once for each snippet of JS and is passed that\n * snippet and the its original associated source's line/column location.\n *\n * @param aFn The traversal function.\n */\nSourceNode.prototype.walk = function SourceNode_walk(aFn) {\n  var chunk;\n  for (var i = 0, len = this.children.length; i < len; i++) {\n    chunk = this.children[i];\n    if (chunk[isSourceNode]) {\n      chunk.walk(aFn);\n    }\n    else {\n      if (chunk !== '') {\n        aFn(chunk, { source: this.source,\n                     line: this.line,\n                     column: this.column,\n                     name: this.name });\n      }\n    }\n  }\n};\n\n/**\n * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between\n * each of `this.children`.\n *\n * @param aSep The separator.\n */\nSourceNode.prototype.join = function SourceNode_join(aSep) {\n  var newChildren;\n  var i;\n  var len = this.children.length;\n  if (len > 0) {\n    newChildren = [];\n    for (i = 0; i < len-1; i++) {\n      newChildren.push(this.children[i]);\n      newChildren.push(aSep);\n    }\n    newChildren.push(this.children[i]);\n    this.children = newChildren;\n  }\n  return this;\n};\n\n/**\n * Call String.prototype.replace on the very right-most source snippet. Useful\n * for trimming whitespace from the end of a source node, etc.\n *\n * @param aPattern The pattern to replace.\n * @param aReplacement The thing to replace the pattern with.\n */\nSourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {\n  var lastChild = this.children[this.children.length - 1];\n  if (lastChild[isSourceNode]) {\n    lastChild.replaceRight(aPattern, aReplacement);\n  }\n  else if (typeof lastChild === 'string') {\n    this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);\n  }\n  else {\n    this.children.push(''.replace(aPattern, aReplacement));\n  }\n  return this;\n};\n\n/**\n * Set the source content for a source file. This will be added to the SourceMapGenerator\n * in the sourcesContent field.\n *\n * @param aSourceFile The filename of the source file\n * @param aSourceContent The content of the source file\n */\nSourceNode.prototype.setSourceContent =\n  function SourceNode_setSourceContent(aSourceFile, aSourceContent) {\n    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;\n  };\n\n/**\n * Walk over the tree of SourceNodes. The walking function is called for each\n * source file content and is passed the filename and source content.\n *\n * @param aFn The traversal function.\n */\nSourceNode.prototype.walkSourceContents =\n  function SourceNode_walkSourceContents(aFn) {\n    for (var i = 0, len = this.children.length; i < len; i++) {\n      if (this.children[i][isSourceNode]) {\n        this.children[i].walkSourceContents(aFn);\n      }\n    }\n\n    var sources = Object.keys(this.sourceContents);\n    for (var i = 0, len = sources.length; i < len; i++) {\n      aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);\n    }\n  };\n\n/**\n * Return the string representation of this source node. Walks over the tree\n * and concatenates all the various snippets together to one string.\n */\nSourceNode.prototype.toString = function SourceNode_toString() {\n  var str = \"\";\n  this.walk(function (chunk) {\n    str += chunk;\n  });\n  return str;\n};\n\n/**\n * Returns the string representation of this source node along with a source\n * map.\n */\nSourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {\n  var generated = {\n    code: \"\",\n    line: 1,\n    column: 0\n  };\n  var map = new SourceMapGenerator(aArgs);\n  var sourceMappingActive = false;\n  var lastOriginalSource = null;\n  var lastOriginalLine = null;\n  var lastOriginalColumn = null;\n  var lastOriginalName = null;\n  this.walk(function (chunk, original) {\n    generated.code += chunk;\n    if (original.source !== null\n        && original.line !== null\n        && original.column !== null) {\n      if(lastOriginalSource !== original.source\n         || lastOriginalLine !== original.line\n         || lastOriginalColumn !== original.column\n         || lastOriginalName !== original.name) {\n        map.addMapping({\n          source: original.source,\n          original: {\n            line: original.line,\n            column: original.column\n          },\n          generated: {\n            line: generated.line,\n            column: generated.column\n          },\n          name: original.name\n        });\n      }\n      lastOriginalSource = original.source;\n      lastOriginalLine = original.line;\n      lastOriginalColumn = original.column;\n      lastOriginalName = original.name;\n      sourceMappingActive = true;\n    } else if (sourceMappingActive) {\n      map.addMapping({\n        generated: {\n          line: generated.line,\n          column: generated.column\n        }\n      });\n      lastOriginalSource = null;\n      sourceMappingActive = false;\n    }\n    for (var idx = 0, length = chunk.length; idx < length; idx++) {\n      if (chunk.charCodeAt(idx) === NEWLINE_CODE) {\n        generated.line++;\n        generated.column = 0;\n        // Mappings end at eol\n        if (idx + 1 === length) {\n          lastOriginalSource = null;\n          sourceMappingActive = false;\n        } else if (sourceMappingActive) {\n          map.addMapping({\n            source: original.source,\n            original: {\n              line: original.line,\n              column: original.column\n            },\n            generated: {\n              line: generated.line,\n              column: generated.column\n            },\n            name: original.name\n          });\n        }\n      } else {\n        generated.column++;\n      }\n    }\n  });\n  this.walkSourceContents(function (sourceFile, sourceContent) {\n    map.setSourceContent(sourceFile, sourceContent);\n  });\n\n  return { code: generated.code, map: map };\n};\n\nexports.SourceNode = SourceNode;\n"],"names":["swap","ary","x","y","temp","doQuickSort","comparator","p","r","i","low","high","Math","round","random","pivot","j","q","exports","length","base64VLQ","util","ArraySet","MappingList","SourceMapGenerator","aArgs","this","_file","getArg","_sourceRoot","_skipValidation","_sources","_names","_mappings","_sourcesContents","prototype","_version","fromSourceMap","aSourceMapConsumer","sourceRoot","generator","file","eachMapping","mapping","newMapping","generated","line","generatedLine","column","generatedColumn","source","relative","original","originalLine","originalColumn","name","addMapping","sources","forEach","sourceFile","content","sourceContentFor","setSourceContent","_validateMapping","String","has","add","aSourceFile","aSourceContent","Object","create","toSetString","keys","applySourceMap","aSourceMapPath","Error","newSources","newNames","unsortedForEach","originalPositionFor","join","aGenerated","aOriginal","aSource","aName","JSON","stringify","_serializeMappings","next","nameIdx","sourceIdx","previousGeneratedColumn","previousGeneratedLine","previousOriginalColumn","previousOriginalLine","previousName","previousSource","result","mappings","toArray","len","compareByGeneratedPositionsInflated","encode","indexOf","_generateSourcesContent","aSources","aSourceRoot","map","key","hasOwnProperty","call","toJSON","version","names","sourcesContent","toString","REGEX_NEWLINE","isSourceNode","SourceNode","aLine","aColumn","aChunks","children","sourceContents","fromStringWithSourceMap","aGeneratedCode","aRelativePath","node","remainingLines","split","shiftNextLine","shift","lastGeneratedLine","lastGeneratedColumn","lastMapping","code","nextLine","substr","addMappingWithCode","undefined","aChunk","Array","isArray","chunk","TypeError","push","prepend","unshift","walk","aFn","aSep","newChildren","replaceRight","aPattern","aReplacement","lastChild","replace","walkSourceContents","fromSetString","str","toStringWithSourceMap","sourceMappingActive","lastOriginalSource","lastOriginalLine","lastOriginalColumn","lastOriginalName","idx","charCodeAt","sourceContent"],"sourceRoot":""}