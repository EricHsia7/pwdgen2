/**
 * Safari 10.3 had a bug where async arrow function expressions within any class method would throw.
 * Also, any references to the class instance via `this` within those methods would also throw (once the initial bug was fixed).
 * This is fixed simply by renaming any declarations in the left/init part of a For* statement so they don't shadow parameters.
 * @see https://bugs.webkit.org/show_bug.cgi?id=166879
 *
 * @example
 *   class X{ a(){ async () => {}; } }   // throws
 *   class X{ a(){ async function() {}; } }   // works
 *
 * @example
 *   class X{ a(){
 *     async () => this.a;   // throws
 *   } }
 *   class X{ a(){
 *     var _this=this;
 *     async function() { return _this.a };   // works
 *   } }
 */

const OPTS = {
	allowInsertArrow: false,
	specCompliant: false
};

export default ({ types: t }) => ({
	name: 'transform-async-arrows-in-class',
	visitor: {
		ArrowFunctionExpression(path) {
			if (path.node.async && path.findParent(t.isClassMethod)) {
				path.arrowFunctionToExpression(OPTS);
				// This could possibly help avoid minifiers stripping the function name, but that's not this plugin's job.
				// path.node.id = path.scope.generateUidIdentifierBasedOnNode(path.node, '_');
			}
		}
	}
});
