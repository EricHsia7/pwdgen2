import { babel } from '../../../test/_util';
import plugin from '.';

const CONFIG = {
	plugins: [
		plugin
	]
};

describe('transform-tagged-template-caching', () => {
	it('should ignore template literals', () => {
		expect(babel('`a`;', CONFIG)).toEqual('`a`;');
		expect(babel('t(`a`);', CONFIG)).toEqual('t(`a`);');
		expect(babel('t;`a`;', CONFIG)).toEqual('t;`a`;');
	});

	it('should wrap a single tag in a dedicated proxy with cache', () => {
		expect(babel('t`a`;', CONFIG)).toEqual('let _=t=>t,_t;t(_t||(_t=_`a`));');
		expect(babel('x``;', CONFIG)).toEqual('let _=t=>t,_t;x(_t||(_t=_``));');
	});

	it('should wrap a multiple tags in proxies with caches', () => {
		expect(babel('t`a`;x``;', CONFIG)).toEqual('let _=t=>t,_t,_t2;t(_t||(_t=_`a`));x(_t2||(_t2=_``));');
	});

	it('should support dynamic tags', () => {
		expect(babel('fn()``;', CONFIG)).toMatch('let _=t=>t,_t;fn()(_t||(_t=_``))');
	});

	it('should support scoped/local tag references', () => {
		expect(babel('t=>t`a`;', CONFIG)).toMatch('let _=t=>t,_t;t=>t(_t||(_t=_`a`))');
		expect(babel('for(let t of[])t`a`;', CONFIG)).toMatch('let _=t=>t,_t;for(let t of[])t(_t||(_t=_`a`));');
	});

	it('should support dynamic expressions', () => {
		expect(babel('t=>t`a${1}b${t}${["hello"]}`;', CONFIG)).toMatch('let _=t=>t,_t;t=>t(_t||(_t=_`a${0}b${0}${0}`),1,t,["hello"])');
	});

	it('should prevent identity tag collisions', () => {
		expect(babel('const _=1;t``;', CONFIG)).toMatch('let _2=t=>t,_t;const _=1;t(_t||(_t=_2``));');
	});

	it('should avoid duplicate Strings reuse in Safari 11', () => {
		// Safari 11 incorrectly reuses cached Strings value for same-quasi tagged templates sharing a block
		expect(babel('x`a`===x`a`;', CONFIG)).toEqual('let _=t=>t,_t,_t2;x(_t||(_t=_`a`))===x(_t2||(_t2=_`a`));');
		expect(babel('x`a`===y`a`;', CONFIG)).toEqual('let _=t=>t,_t,_t2;x(_t||(_t=_`a`))===y(_t2||(_t2=_`a`));');
	});

	it('should pass same strings reference on repeated calls', () => {
		const f = eval(babel('(function f(){return Object`a`;})'));
		expect(f()).toStrictEqual(f());
		expect(f()).toStrictEqual(new f());
		expect(f()).toStrictEqual(f.call({}));
	});

	it('should pass different strings references for different callsites', () => {
		const f = eval(babel('(function f(){return Object`a`===Object`b`;})'));
		expect(f()).toEqual(false);
	});

	it('should pass different strings references for different callsites with same quasis', () => {
		const f = eval(babel('(function f(){return Object`a`===Object`a`;})'));
		expect(f()).toEqual(false);
	});
});
